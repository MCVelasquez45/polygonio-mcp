"""CLI financial analyst using OpenAI Agents SDK, GPT-5, and Polygon.io MCP server.

This script launches a stdio MCP server for Polygon.io tools, runs a single
analysis agent with an input guardrail to ensure finance-related prompts, and
renders only the agent's final output. Users can optionally save analyses as
Markdown reports in the `reports/` directory.
"""

import os
import asyncio
from dotenv import load_dotenv
from rich.console import Console
from rich.markdown import Markdown
from datetime import datetime, timedelta
from pathlib import Path
import re
from typing import Any, Dict, List, Optional
from textwrap import dedent

import httpx

from agents import Agent, InputGuardrail, GuardrailFunctionOutput, Runner, SQLiteSession, AsyncOpenAI, trace, function_tool, ModelSettings
from agents.exceptions import InputGuardrailTripwireTriggered
from agents.models.openai_responses import OpenAIResponsesModel
from agents.mcp import MCPServerStdio
from pydantic import BaseModel

load_dotenv()

console = Console()
POLYGON_BASE_URL = "https://api.polygon.io"

# Models
class FinanceOutput(BaseModel):
    """Structured result from the guardrail check.
    """
    is_about_finance: bool
    reasoning: str

@function_tool
async def save_analysis_report(content: str, title: str = None, category: str = "general") -> str:
    """Persist a Markdown report to `reports/<timestamp>_<title>.md`.
    """
    reports_dir = Path("reports")
    reports_dir.mkdir(parents=True, exist_ok=True)
    
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    title = title or f"analysis_{timestamp}"
    safe_title = re.sub(r'[^\w\s-]', '', title).replace(' ', '_')
    filepath = reports_dir / f"{timestamp}_{safe_title}.md"
    
    report_body = dedent(f"""\
        # {title}

        **Generated:** {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
        **Category:** {category}

        ---

        {content}

        ---
        *Report generated by Market Analysis Agent*
    """).strip() + "\n"
    
    filepath.write_text(report_body, encoding='utf-8')
    return f"Report saved: {filepath}"

def _require_env(key: str) -> str:
    value = os.getenv(key)
    if not value:
        raise RuntimeError(f"{key} not set in environment.")
    return value

def _midpoint(bid: Optional[float], ask: Optional[float]) -> Optional[float]:
    if bid is None or ask is None:
        return None
    if bid <= 0 or ask <= 0 or ask < bid:
        return None
    return round((bid + ask) / 2.0, 4)


class PolygonDataFetcher:
    """Helper for interacting with Polygon.io endpoints our account can access."""

    def __init__(self, api_key: str, base_url: str = POLYGON_BASE_URL, timeout: float = 20.0):
        self.api_key = api_key
        self.base_url = base_url.rstrip("/")
        self.timeout = timeout

    async def get(self, endpoint: str, params: Dict[str, Any] | None = None) -> Dict[str, Any]:
        params = dict(params or {})
        params["apiKey"] = self.api_key
        url = f"{self.base_url}{endpoint}"
        async with httpx.AsyncClient(timeout=self.timeout) as client:
            response = await client.get(url, params=params)
            response.raise_for_status()
            return response.json()

    async def get_options_snapshot(
        self,
        ticker: str,
        expiration_date: str | None = None,
        contract_type: str | None = None,
        limit: int = 25,
        sort: str | None = "gamma",
    ) -> Dict[str, Any]:
        params: Dict[str, Any] = {
            "limit": max(1, min(limit, 250)),
        }
        if expiration_date:
            params["expiration_date"] = expiration_date
        if contract_type:
            params["contract_type"] = contract_type
        if sort:
            params["sort"] = sort

        payload = await self.get(f"/v3/snapshot/options/{ticker.upper()}", params)
        results: List[Dict[str, Any]] = []
        for option in payload.get("results", []):
            details = option.get("details") or {}
            greeks = option.get("greeks") or {}
            last_quote = option.get("last_quote") or {}
            day = option.get("day") or {}

            results.append({
                "contract": details.get("ticker"),
                "expiration": details.get("expiration_date"),
                "strike": details.get("strike_price"),
                "contract_type": details.get("contract_type"),
                "exercise_style": details.get("exercise_style"),
                "change_percent": day.get("change_percent"),
                "open_interest": option.get("open_interest"),
                "implied_volatility": option.get("implied_volatility"),
                "volume": day.get("volume"),
                "bid": last_quote.get("bid"),
                "ask": last_quote.get("ask"),
                "mid": _midpoint(last_quote.get("bid"), last_quote.get("ask")),
                "delta": greeks.get("delta"),
                "gamma": greeks.get("gamma"),
                "theta": greeks.get("theta"),
                "vega": greeks.get("vega"),
                "rho": greeks.get("rho"),
            })

        return {
            "underlying": ticker.upper(),
            "query_count": payload.get("queryCount"),
            "status": payload.get("status"),
            "results_count": len(results),
            "options": results,
        }

    async def get_option_contract_snapshot(self, underlying: str, contract: str) -> Dict[str, Any]:
        payload = await self.get(f"/v3/snapshot/options/{underlying.upper()}/{contract}")
        result = payload.get("results") or {}
        details = result.get("details") or {}
        greeks = result.get("greeks") or {}
        quote = result.get("last_quote") or {}
        trade = result.get("last_trade") or {}
        day = result.get("day") or {}

        return {
            "contract": details.get("ticker"),
            "underlying": underlying.upper(),
            "expiration": details.get("expiration_date"),
            "strike": details.get("strike_price"),
            "contract_type": details.get("contract_type"),
            "exercise_style": details.get("exercise_style"),
            "implied_volatility": result.get("implied_volatility"),
            "open_interest": result.get("open_interest"),
            "day": {
                "change": day.get("change"),
                "change_percent": day.get("change_percent"),
                "volume": day.get("volume"),
                "vwap": day.get("vwap"),
            },
            "last_quote": {
                "bid": quote.get("bid"),
                "ask": quote.get("ask"),
                "mid": _midpoint(quote.get("bid"), quote.get("ask")),
                "bid_size": quote.get("bid_size"),
                "ask_size": quote.get("ask_size"),
                "timestamp": quote.get("timestamp"),
            },
            "last_trade": {
                "price": trade.get("price"),
                "size": trade.get("size"),
                "exchange": trade.get("exchange"),
                "timestamp": trade.get("timestamp"),
            },
            "greeks": greeks,
        }

    async def get_option_quotes(self, option_ticker: str, limit: int = 500) -> Dict[str, Any]:
        payload = await self.get(
            f"/v3/quotes/{option_ticker}",
            {
                "limit": max(1, min(limit, 5000)),
                "sort": "timestamp",
                "order": "desc",
            },
        )
        return {
            "contract": option_ticker,
            "status": payload.get("status"),
            "query_count": payload.get("queryCount"),
            "results_count": payload.get("resultsCount"),
            "results": payload.get("results", []),
            "next_url": payload.get("next_url"),
        }

    async def get_option_trades(self, option_ticker: str, limit: int = 500) -> Dict[str, Any]:
        payload = await self.get(
            f"/v3/trades/{option_ticker}",
            {
                "limit": max(1, min(limit, 5000)),
                "sort": "timestamp",
                "order": "desc",
            },
        )
        return {
            "contract": option_ticker,
            "status": payload.get("status"),
            "query_count": payload.get("queryCount"),
            "results_count": payload.get("resultsCount"),
            "results": payload.get("results", []),
            "next_url": payload.get("next_url"),
        }

    async def get_intraday_aggregates(
        self,
        ticker: str,
        multiplier: int,
        timespan: str,
        from_date: str,
        to_date: str,
        limit: int,
        adjusted: bool = True,
    ) -> Dict[str, Any]:
        payload = await self.get(
            f"/v2/aggs/ticker/{ticker.upper()}/range/{multiplier}/{timespan}/{from_date}/{to_date}",
            {
                "adjusted": adjusted,
                "sort": "asc",
                "limit": max(1, min(limit, 50000)),
            },
        )
        return {
            "ticker": ticker.upper(),
            "status": payload.get("status"),
            "results_count": payload.get("resultsCount"),
            "results": payload.get("results", []),
        }

    async def get_exchanges(self, asset_class: str = "options", locale: str = "us") -> Dict[str, Any]:
        payload = await self.get(
            "/v3/reference/exchanges",
            {"asset_class": asset_class, "locale": locale},
        )
        results = payload.get("results", [])
        return {
            "status": payload.get("status"),
            "results_count": payload.get("resultsCount") or len(results),
            "results": results,
            "asset_class": asset_class,
            "locale": locale,
        }

    async def get_dividends(self, ticker: str, limit: int = 20) -> Dict[str, Any]:
        payload = await self.get(
            "/v3/reference/dividends",
            {
                "ticker": ticker.upper(),
                "limit": max(1, min(limit, 100)),
                "order": "desc",
                "sort": "pay_date",
            },
        )
        return {
            "ticker": ticker.upper(),
            "status": payload.get("status"),
            "results_count": payload.get("resultsCount"),
            "results": payload.get("results", []),
            "next_url": payload.get("next_url"),
        }

    async def get_earnings(self, ticker: str, limit: int = 20) -> Dict[str, Any]:
        payload = await self.get(
            "/vX/reference/financials",
            {
                "ticker": ticker.upper(),
                "type": "Q",
                "limit": max(1, min(limit, 100)),
                "sort": "-fiscal_period",
            },
        )
        return {
            "ticker": ticker.upper(),
            "status": payload.get("status"),
            "results_count": payload.get("resultsCount"),
            "results": payload.get("results", []),
            "next_url": payload.get("next_url"),
        }

    async def get_financials(
        self,
        ticker: str,
        limit: int = 5,
        timeframe: str | None = "quarterly",
    ) -> Dict[str, Any]:
        params: Dict[str, Any] = {
            "ticker": ticker.upper(),
            "limit": max(1, min(limit, 20)),
            "sort": "-fiscal_period",
        }
        if timeframe:
            params["timeframe"] = timeframe

        payload = await self.get("/vX/reference/financials", params)
        return {
            "ticker": ticker.upper(),
            "status": payload.get("status"),
            "results_count": payload.get("resultsCount"),
            "results": payload.get("results", []),
            "next_url": payload.get("next_url"),
        }

    async def get_ticker_sentiment(
        self,
        ticker: str,
        limit: int = 10,
        order: str = "asc",
        sort: str = "published_utc",
    ) -> Dict[str, Any]:
        params: Dict[str, Any] = {
            "order": order,
            "limit": max(1, min(limit, 100)),
            "sort": sort,
        }
        if ticker:
            params["ticker"] = ticker.upper()

        payload = await self.get("/v2/reference/news", params)
        articles = []
        for article in payload.get("results", []):
            publisher = article.get("publisher") or {}
            articles.append({
                "id": article.get("id"),
                "title": article.get("title"),
                "published_utc": article.get("published_utc"),
                "tickers": article.get("tickers"),
                "description": article.get("description"),
                "article_url": article.get("article_url"),
                "amp_url": article.get("amp_url"),
                "keywords": article.get("keywords"),
                "publisher_name": publisher.get("name"),
            })

        results_count = payload.get("resultsCount") or payload.get("count") or len(articles)
        return {
            "ticker": ticker.upper(),
            "status": payload.get("status"),
            "results_count": results_count,
            "articles": articles,
            "next_url": payload.get("next_url"),
        }


_polygon_fetcher: PolygonDataFetcher | None = None


def _get_polygon_fetcher() -> PolygonDataFetcher:
    global _polygon_fetcher
    if _polygon_fetcher is None:
        api_key = _require_env("POLYGON_API_KEY")
        _polygon_fetcher = PolygonDataFetcher(api_key=api_key)
    return _polygon_fetcher

@function_tool
async def get_polygon_options_snapshot(
    ticker: str,
    expiration_date: str | None = None,
    contract_type: str | None = None,
    limit: int = 25,
    sort: str | None = "gamma"
) -> Dict[str, Any]:
    """Fetch snapshot data for an underlying's option contracts."""
    fetcher = _get_polygon_fetcher()
    return await fetcher.get_options_snapshot(ticker, expiration_date, contract_type, limit, sort)

@function_tool
async def get_polygon_option_contract_snapshot(underlying: str, contract: str) -> Dict[str, Any]:
    """Fetch detailed snapshot for a specific option contract."""
    fetcher = _get_polygon_fetcher()
    return await fetcher.get_option_contract_snapshot(underlying, contract)

@function_tool
async def get_polygon_ticker_sentiment(
    ticker: str,
    limit: int = 10,
    order: str = "asc",
    sort: str = "published_utc"
) -> Dict[str, Any]:
    """Retrieve recent Polygon.io news articles for a ticker."""
    fetcher = _get_polygon_fetcher()
    return await fetcher.get_ticker_sentiment(ticker, limit, order, sort)

@function_tool
async def get_fred_series(
    series_id: str,
    start_date: str | None = None,
    end_date: str | None = None,
    limit: int = 120
) -> Dict[str, Any]:
    """Fetch macroeconomic series data from the Federal Reserve (FRED).

    Args:
        series_id: FRED series identifier (e.g., `DGS3MO`, `T10Y2Y`).
        start_date: Optional start date (YYYY-MM-DD).
        end_date: Optional end date (YYYY-MM-DD).
        limit: Maximum observations to return (defaults to 120).
    """
    fred_key = _require_env("FRED_API_KEY")
    params = {
        "series_id": series_id,
        "api_key": fred_key,
        "file_type": "json",
        "sort_order": "asc",
        "limit": max(1, min(limit, 1000)),
    }
    if start_date:
        params["observation_start"] = start_date
    if end_date:
        params["observation_end"] = end_date

    url = "https://api.stlouisfed.org/fred/series/observations"
    async with httpx.AsyncClient(timeout=20.0) as client:
        response = await client.get(url, params=params)
        response.raise_for_status()
        payload = response.json()

    observations = payload.get("observations", [])
    valid_values = [
        obs for obs in observations
        if obs.get("value") not in (None, "", ".")
    ]

    latest = valid_values[-1] if valid_values else None
    previous = valid_values[-2] if len(valid_values) > 1 else None

    def _to_float(value: Optional[str]) -> Optional[float]:
        if value in (None, "", "."):
            return None
        try:
            return float(value)
        except ValueError:
            return None

    latest_value = _to_float(latest.get("value")) if latest else None
    previous_value = _to_float(previous.get("value")) if previous else None
    change = None
    if latest_value is not None and previous_value is not None:
        change = latest_value - previous_value

    return {
        "series_id": series_id,
        "observations": valid_values,
        "latest": latest,
        "latest_value": latest_value,
        "previous": previous,
        "change": change,
        "units": payload.get("units"),
        "frequency": payload.get("frequency"),
        "notes": payload.get("notes"),
    }

async def _fred_release_dates(
    start_date: str | None = None,
    end_date: str | None = None,
    limit: int = 25,
    sort_order: str = "asc"
) -> Dict[str, Any]:
    fred_key = _require_env("FRED_API_KEY")
    if start_date is None:
        start_date = datetime.utcnow().strftime("%Y-%m-%d")
    if end_date is None:
        end_date = (datetime.utcnow() + timedelta(days=45)).strftime("%Y-%m-%d")

    params = {
        "api_key": fred_key,
        "file_type": "json",
        "limit": max(1, min(limit, 500)),
        "sort_order": sort_order,
        "include_release_dates_with_no_data": "false",
        "include_release_child_series": "false",
        "realtime_start": start_date,
        "realtime_end": end_date,
        "offset": 0,
    }

    url = "https://api.stlouisfed.org/fred/releases/dates"
    async with httpx.AsyncClient(timeout=20.0) as client:
        response = await client.get(url, params=params)
        response.raise_for_status()
        payload = response.json()

    releases = payload.get("release_dates", [])
    normalized = []
    for entry in releases:
        normalized.append({
            "release_id": entry.get("release_id"),
            "release_name": entry.get("release_name"),
            "date": entry.get("date"),
            "last_updated": entry.get("release_last_updated"),
        })

    return {
        "status": "ok",
        "count": len(normalized),
        "start_date": start_date,
        "end_date": end_date,
        "releases": normalized[:limit],
    }

@function_tool
async def get_fred_release_calendar(
    start_date: str | None = None,
    end_date: str | None = None,
    limit: int = 25,
    sort_order: str = "asc"
) -> Dict[str, Any]:
    """Retrieve upcoming macroeconomic releases from FRED.

    Args:
        start_date: Beginning of window (YYYY-MM-DD). Defaults to today.
        end_date: End of window (YYYY-MM-DD). Defaults to ~45 days out.
        limit: Maximum number of releases to return (<=500).
        sort_order: 'asc' or 'desc'.
    """
    return await _fred_release_dates(start_date, end_date, limit, sort_order)

@function_tool
async def get_polygon_option_quotes(option_ticker: str, limit: int = 500) -> Dict[str, Any]:
    """Retrieve NBBO quotes for an option contract."""
    fetcher = _get_polygon_fetcher()
    return await fetcher.get_option_quotes(option_ticker, limit)

@function_tool
async def get_polygon_option_trades(option_ticker: str, limit: int = 500) -> Dict[str, Any]:
    """Retrieve recent prints for an option contract."""
    fetcher = _get_polygon_fetcher()
    return await fetcher.get_option_trades(option_ticker, limit)

@function_tool
async def get_polygon_intraday_aggregates(
    ticker: str,
    date: str,
    multiplier: int = 1,
    timespan: str = "minute",
    limit: int = 500,
    end_date: str | None = None
) -> Dict[str, Any]:
    """Retrieve intraday aggregates for a given trading day or range."""
    fetcher = _get_polygon_fetcher()
    to_date = end_date or date
    return await fetcher.get_intraday_aggregates(ticker, multiplier, timespan, date, to_date, limit)


@function_tool
async def get_polygon_exchanges(asset_class: str = "options", locale: str = "us") -> Dict[str, Any]:
    """List Polygon exchanges available for the supplied asset class."""
    fetcher = _get_polygon_fetcher()
    return await fetcher.get_exchanges(asset_class, locale)

@function_tool
async def get_polygon_earnings(ticker: str, limit: int = 20) -> Dict[str, Any]:
    """Fetch quarterly earnings data backed by Polygon financials."""
    fetcher = _get_polygon_fetcher()
    return await fetcher.get_earnings(ticker, limit)

@function_tool
async def get_polygon_dividends(ticker: str, limit: int = 20) -> Dict[str, Any]:
    """Fetch dividend history for a ticker."""
    fetcher = _get_polygon_fetcher()
    return await fetcher.get_dividends(ticker, limit)

@function_tool
async def get_polygon_financials(
    ticker: str,
    limit: int = 5,
    timeframe: str | None = "quarterly"
) -> Dict[str, Any]:
    """Retrieve detailed company financials."""
    fetcher = _get_polygon_fetcher()
    return await fetcher.get_financials(ticker, limit, timeframe)

guardrail_agent = Agent(
    name="Guardrail check",
    instructions=
    """Classify if the user query is finance-related.
    Include: stocks, ETFs, crypto, forex, market news, fundamentals, economic indicators, ROI calcs, corporate actions.
    Exclude: non-financial topics (cooking, general trivia, unrelated tech).
    Disambiguate: if term (e.g., Apple, Tesla) could be both, check for finance context words (price, market, earnings, shares). If unclear, return non-finance.
    Output: is_about_finance: bool, reasoning: brief why/why not.""",
    output_type=FinanceOutput,
)

async def finance_guardrail(context, agent, input_data):
    """Validate that the prompt is finance-related before running the agent.
    """
    result = await Runner.run(guardrail_agent, input_data, context=context)
    final_output = result.final_output_as(FinanceOutput)
    return GuardrailFunctionOutput(
        output_info=final_output,
        tripwire_triggered=not final_output.is_about_finance,
    )

def create_polygon_mcp_server():
    """Create a stdio MCP server instance configured with POLYGON_API_KEY.
    """
    api_key = os.getenv("POLYGON_API_KEY")
    if not api_key:
        raise Exception("POLYGON_API_KEY not set in environment.")
    return MCPServerStdio(params={
        "command": "uvx",
        "args": ["--from", "git+https://github.com/polygon-io/mcp_polygon@v0.4.0", "mcp_polygon"],
        "env": {**os.environ, "POLYGON_API_KEY": api_key}
    })

# Output functions
def print_response(result):
    """Render only the agent's final output with basic Markdown support."""
    console.print("\n[bold green]✔ Query processed successfully![/bold green]")
    console.print("[bold]Agent Response:[/bold]")
    # Print only the final output from the run result (per OpenAI Agents SDK)
    final_output = getattr(result, "final_output", result)
    final_text = str(final_output)
    console.print(Markdown(final_text) if any(tag in final_text for tag in ["#", "*", "`", "-", ">"]) else final_text.strip())
    console.print("---------------------\n")

def print_error(error, error_type="Error"):
    """Display errors in a consistent, readable format for the CLI."""
    console.print(f"\n[bold red]!!! {error_type} !!![/bold red]")
    console.print(str(error).strip())
    console.print("------------------\n")

def print_guardrail_error(exception):
    """Explain why a prompt was blocked by the finance guardrail."""
    console.print("\n[bold yellow]⚠ Guardrail Triggered[/bold yellow]")
    console.print("[yellow]This query is not related to finance.[/yellow]")
    if hasattr(exception, 'output_info') and exception.output_info:
        console.print(f"[dim]Reasoning: {exception.output_info.reasoning}[/dim]")
    console.print("[dim]Please ask about stock prices, market data, financial analysis, economic indicators, or company financials.[/dim]")
    console.print("------------------\n")

# Main CLI
async def cli_async():
    """Run the interactive CLI loop.
    """
    print("Welcome to the GPT-5 powered Market Analysis Agent. Type 'exit' to quit.")
    
    try:
        session = SQLiteSession("finance_conversation")
        server = create_polygon_mcp_server() 
        
        async with server:
            while True:
                try:
                    user_input = input('> ').strip()
                    if user_input.lower() == 'exit':
                        print("Goodbye!")
                        break
                    
                    if not user_input or len(user_input.strip()) < 2:
                        print("Please enter a valid query (at least 2 characters).")
                        continue
                    
                    with trace("Polygon.io Demo"):
                        try:
                            analysis_agent = Agent(
                                name="Financial Analysis Agent",
                                instructions=(
                                    "Financial analysis agent. Steps:\n"
                                    "1. Verify finance-related using guardrail\n"
                                    "2. Call Polygon tools precisely; pull the minimal required data.\n"
                                    "3. Include disclaimers.\n"
                                    "4. Offer to save reports if not asked by the user to save a report.\n\n"
                                    "RULES:\n"
                                    "Double-check math; limit news to ≤3 articles/ticker in date range.\n" 
                                    "If the user asks to save a report, save it to the reports folder using the save_analysis_report tool.\n"
                                    "When using any polygon.io data tools, be mindful of how much data you pull based \n"
                                    "on the users input to minimize context being exceeded.\n"
                                    "If data unavailable or tool fails, explain gracefully — never fabricate.\n"
                                    "TOOLS:\n" 
                                    "Polygon.io data, save_analysis_report, get_polygon_options_snapshot,\n"
                                    "get_polygon_option_contract_snapshot, get_polygon_option_quotes,\n"
                                    "get_polygon_option_trades, get_polygon_intraday_aggregates,\n"
                                    "get_polygon_exchanges, get_polygon_ticker_sentiment,\n"
                                    "get_polygon_earnings, get_polygon_dividends, get_polygon_financials,\n"
                                    "get_fred_series, get_fred_release_calendar\n"
                                    "Disclaimer: Not financial advice. For informational purposes only."
                                ),
                                mcp_servers=[server],
                                tools=[
                                    save_analysis_report,
                                    get_polygon_options_snapshot,
                                    get_polygon_option_contract_snapshot,
                                    get_polygon_option_quotes,
                                    get_polygon_option_trades,
                                    get_polygon_intraday_aggregates,
                                    get_polygon_exchanges,
                                    get_polygon_ticker_sentiment,
                                    get_polygon_dividends,
                                    get_polygon_earnings,
                                    get_polygon_financials,
                                    get_fred_series,
                                    get_fred_release_calendar,
                                ],
                                input_guardrails=[InputGuardrail(guardrail_function=finance_guardrail)],
                                model=OpenAIResponsesModel(model="gpt-5", openai_client=AsyncOpenAI()),
                                model_settings = ModelSettings(truncation="auto")
                            )
                            output = await Runner.run(analysis_agent, user_input, session=session)
                            print("\r", end="")
                            print_response(output)
                        except InputGuardrailTripwireTriggered as e:
                            print("\r", end="")
                            print_guardrail_error(e)
                        except Exception as e:
                            print("\r", end="")
                            print_error(e, "Agent Error")
                            
                except (EOFError, KeyboardInterrupt):
                    print("\nGoodbye!")
                    break
                except Exception as e:
                    print_error(e, "Unexpected Error")
                    
    except Exception as e:
        print_error(e, "Setup Error")
    finally:
        print("Market Analysis Agent shutdown complete")

if __name__ == "__main__":
    asyncio.run(cli_async()) 
